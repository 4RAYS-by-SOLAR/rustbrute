
# Описание

Данный скрипт предназначен для перебора параметров оптимизации, которые влияют на сборку исполняемых файлов, написанных на Rust. Это делается для того, чтобы создавать более эффективные сигнатуры, которые смогли бы распознать большее количество библиотечных функций, что позволило бы упростить анализ сэмплов на Rust.

В репозитории можно заметить скрипт [rustbinsign](https://github.com/N0fix/rustbinsign), он используется для компиляции крейтов с разными параметрами. Здесь немного изменённая версия этого скрипта, в котором было добавлено несколько параметров, для более удобного использования.

Помимо этого в репозитории есть yara правило, которое на основе некоторых строк в исследуемом файле может вывести свои догадки по поводу некоторых параметров оптимизации. Это может повысить уверенность в тех параметрах, которые будут получены после работы основного скрипта.
# Принцип работы
Для того, чтобы найти наиболее подходящие параметры, скрипт перебирает их комбинации и каждый раз компилирует выбранный крейт. После компиляции, из исполняемого файла достаются функции, которые предположительно принадлежат этому крейту и те же функции достаются из только что скомпилированного крейта. После этого функции сравниваются с помощью [Diaphora](https://github.com/joxeankoret/diaphora), а полученный процент сходства сравнивается с текущим максимальным. Когда все комбинации будут опробованы, пользователь получает максимальный процент сходства и параметры оптимизации, которые ему соответствуют.

Перед запуском пользователь должен вручную определить одну или несколько библиотечных функций в исследуемом файле. В процессе тестирования использовалось не больше трёх функций. Если выбрать большее количество, возможно точность увеличится, но и время работы скрипта тоже станет больше. Чтобы повысить эффективность работы скрипта, нужно по возможности выбирать большие функции. Если в функции будет меньше трёх базовых блоков, возможно diaphora не сможет их сравнить. Также не подойдут функции, которые принадлежат std крейтам, на них оптимизации не распространяются.
## Настройка и запуск
Перед запуском нужно заполнить файл settings.json. Он обязательно должен содержать пути к используемым скриптам, а также может содержать те параметры оптимизации, которые будут использованы при переборе.

Этот файл содержит следующие поля:

func_finder_script: путь к скрипту, который используется для получения нужных функций из скомпилированных библиотек. Он лежит в корневой директории проекта, поэтому путь к нему задан по умолчанию.

idat_path: путь к исполняемому файлу idat.exe. Это текстовый режим IDA, который используется для извлечения функций. Этот исполняемые файл обычно лежит в корневой директории IDA.

diaphora_path: путь к скрипту diaphora.py.

opts: это JSON в котором можно указать параметры оптимизации и их значения. Его наличие в файле не обязательно, так как он уже задан по умолчанию:
```
opts = {

        "opt-level":[0, 1, 2, 3, "s", "z"],

        "lto":["off"],

        "overflow-checks":[True, False],

        "debug-assertions":[True, False],

        "panic":["unwind", "abort"],

        "codegen-units":[1, 16, 256],

        "incremental":[True],

    }
```

Но в случае, если пользователь уже знает значения каких-то параметров, или хочет попробовать конкретные значения, можно переписать json пол умолчанию с помощью settings.json. Чем меньше этих параметров, тем меньше комбинаций для перебора, то есть скрипт выполнится быстрее.

После заполнения настроек в файле, можно переходить к запуску самого скрипта. У него есть несколько аргументов командной строки.

\--config: путь к файлу настроек, по умолчанию задан settings.json

\--lib-func-names: это список имён библиотечных функций, которые будут использованы для сравнения. Пример: `--lib-func-names tokio::runtime::builder::Builder::build tokio::runtime::scheduler::current_thread::Context::park`

\--target-path: путь к исследуемому файлу

\--target-funcs: с помощью этого параметра нужно задать границы, где предположительно находятся исследуемые функции в файле. Задать этот параметр можно в формате `hex_start1:hex_end1 hex_start2:hex_end2` (порядок пар адресов должен соответствовать порядку имён функций, заданных параметром \--lib-func-names). Пример: `--target-funcs 0x140178DF0:0x14017B43D 0x140186610:0x140186BC6`. Здесь первая пара соответствует отрезку памяти, где предположительно находится функция `tokio::runtime::builder::Builder::build`, а вторая пара соответствует функции `tokio::runtime::scheduler::current_thread::Context::park`

\--lib-str: имя библиотеки с указанием версии. Пример: `--lib-str tokio-1.48.0`

\--toolchain: имя тулчейна с которым предположительно компилировался исследуемый файл. Пример: `--toolchain stable-x86_64-pc-windows-msvc`

\--work-dir: директория, которая используется для временного хранения файлов. По умолчанию `opt_brute`

\--skip-install: если указан этот параметр, при запуске скрипта rustbinsign будет пропускаться процесс установки Rust тулчейна, что может сократить время исполнения. Это можно использовать, если вы уверены, что нужный тулчейн уже установлен.

\--clear-tmp: если указан этот параметр, после каждого запуска rustbinsign директория TMP/rustbinsign будет очищаться. Это может быть полезно, если у вас на диске мало свободного места. Но если этот параметр не включать и в параметрах компиляции (opts в settings.json) указать параметр incremental=True, то повторная компиляция будет происходить быстрее, при этом файлы компилируемого крейта могут занять на диске несколько гигабайт в зависимости от выбранного крейта.

## Зависимости

Для работы скрипта дополнительно потребуется:

1) Python 3.10+ с установленным пакетом yara-python
2) IDA Pro
3) [Diaphora](https://github.com/joxeankoret/diaphora)
